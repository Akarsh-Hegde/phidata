import json
from uuid import uuid4
from textwrap import dedent
from typing import List, Any, Optional, Dict, Iterator, Union, Type

from pydantic import BaseModel, ConfigDict, field_validator, Field

from phi.team.run import TeamRun
from phi.llm.base import LLM
from phi.llm.message import Message
from phi.llm.references import References  # noqa: F401
from phi.storage.team import TeamStorage
from phi.assistant import Assistant
from phi.team.task import Task
from phi.memory.team import TeamMemory
from phi.tools.function import Function
from phi.utils.log import logger, set_log_level_to_debug
from phi.utils.message import get_text_from_message
from phi.utils.timer import Timer


class Team(BaseModel):
    # -*- Team settings
    # LLM to use for this Team
    llm: Optional[LLM] = None
    # Team name
    name: Optional[str] = None
    # Team introduction. This is added to the chat history when a run is started.
    introduction: Optional[str] = None
    # Metadata associated with this team
    team_data: Optional[Dict[str, Any]] = None

    # -*- Run settings
    # Run UUID (autogenerated if not set)
    run_id: Optional[str] = Field(None, validate_default=True)
    # Run name
    run_name: Optional[str] = None
    # Metadata associated with this run
    run_data: Optional[Dict[str, Any]] = None

    # -*- User settings
    # ID of the user interacting with this team
    user_id: Optional[str] = None
    # Metadata associated the user interacting with this team
    user_data: Optional[Dict[str, Any]] = None

    # -*- Team members
    # Team assistants
    assistants: Optional[List[Assistant]] = None

    # -*- Tasks for this team (required)
    tasks: Optional[List[Task]] = None
    # Metadata associated with the assistant tasks
    task_data: Optional[Dict[str, Any]] = None

    # -*- Team Memory
    memory: TeamMemory = TeamMemory()

    # -*- Team Storage
    storage: Optional[TeamStorage] = None
    # AssistantRun from the database: DO NOT SET MANUALLY
    db_row: Optional[TeamRun] = None

    # If markdown=true, add instructions to format the output using markdown
    markdown: bool = False

    # -*- Assistant Output Settings
    # Provide an output model for the responses
    output_model: Optional[Union[str, List, Type[BaseModel]]] = None
    # If True, the output is converted into the output_model (pydantic model or json dict)
    parse_output: bool = True
    # -*- Final LLM response i.e. the final output of this assistant
    output: Optional[Any] = None

    # debug_mode=True enables debug logs
    debug_mode: bool = False
    # monitoring=True logs Assistant runs on phidata.com
    monitoring: bool = False

    model_config = ConfigDict(arbitrary_types_allowed=True)

    @field_validator("debug_mode", mode="before")
    def set_log_level(cls, v: bool) -> bool:
        if v:
            set_log_level_to_debug()
            logger.debug("Debug logs enabled")
        return v

    @field_validator("run_id", mode="before")
    def set_run_id(cls, v: Optional[str]) -> str:
        return v if v is not None else str(uuid4())

    @property
    def streamable(self) -> bool:
        return True

    def get_default_task(self) -> Task:
        return Task()

    def assistant_delegation_function(self, assistant: Assistant, index: int) -> Function:
        def _delegate_task_to_assistant(task_description: str) -> str:
            return assistant.run(task_description, stream=False)  # type: ignore

        assistant_name = assistant.name.replace(" ", "_").lower() if assistant.name else f"assistant_{index}"
        delegation_function = Function.from_callable(_delegate_task_to_assistant)
        delegation_function.name = f"delegate_task_to_{assistant_name}"
        delegation_function.description = dedent(
            f"""Use this function to delegate a task to {assistant_name}. Remember to always provide a clear and concise `task_description`.

        Args:
            task_description (str): A clear and concise description of the task the assistant should achieve.
        Returns:
            str: The result of the delegated task.
        """
        )
        return delegation_function

    def get_task_assistant(self, task: Task, message: Optional[Union[List, Dict, str]] = None) -> Assistant:

        delegation_functions = []
        delegation_assistants = []
        # Add team assistants to the delegation functions
        if self.assistants and len(self.assistants) > 0:
            for assistant_index, assistant in enumerate(self.assistants):
                delegation_assistants.append(assistant)
                delegation_functions.append(self.assistant_delegation_function(assistant, assistant_index))
        # Add task assistants to the delegation functions
        if task.assistants and len(task.assistants) > 0:
            for assistant_index, assistant in enumerate(task.assistants):
                delegation_assistants.append(assistant)
                delegation_functions.append(self.assistant_delegation_function(assistant, assistant_index))

        system_prompt = ""
        if delegation_assistants and len(delegation_assistants) > 0:
            system_prompt += "You are the leader of a team of AI Assistants "
            if self.name:
                system_prompt += f"called '{self.name}'.\n"
        else:
            system_prompt += "You are an AI Assistant.\n"

        if task.description:
            system_prompt += f"\nYour task is to: {task.description}.\n"
        # if message is not None:
        #     system_prompt += f"\nThe goal of this team is to: {message}.\n"

        if delegation_assistants and len(delegation_assistants) > 0:
            system_prompt += (
                "You can either respond directly or delegate tasks to assistants in your team depending on their role and "
                "the tools available to them."
            )
            system_prompt += "\n\n<assistants>"
            for assistant_index, assistant in enumerate(delegation_assistants):
                system_prompt += f"\nAssistant {assistant_index+1}:\n"
                if assistant.name:
                    system_prompt += f"Name: {assistant.name}\n"
                if assistant.role:
                    system_prompt += f"Role: {assistant.role}\n"
                if assistant.tools is not None:
                    _tools = []
                    for _tool in assistant.tools:
                        if callable(_tool):
                            _tools.append(_tool.__name__)
                    system_prompt += f"Available tools: {', '.join(_tools)}\n"
            system_prompt += "</assistants>\n"
            system_prompt += "\nYou must review the responses from the assistants and re-run tasks if the result is not satisfactory."

        return Assistant(
            llm=self.llm,
            system_prompt=system_prompt,
            tools=delegation_functions,
        )

    def _run(
        self,
        message: Optional[Union[List, Dict, str]] = None,
        *,
        stream: bool = True,
        **kwargs: Any,
    ) -> Iterator[str]:
        logger.debug(f"*********** Team Run Start: {self.run_id} ***********")

        # -*- Load run from storage
        # self.read_from_storage()

        # Add a default Task if tasks are empty
        tasks = self.tasks
        if tasks is None or len(tasks) == 0:
            tasks = [self.get_default_task()]

        # Final output after running all tasks
        run_output = ""
        # Variable to hold the current task
        current_task: Optional[Task] = None
        # List of tasks that have been run
        previous_tasks: List[Task] = []

        # -*- Generate response by running tasks
        for idx, task in enumerate(tasks, start=1):
            logger.debug(f"*********** Task {idx} Start ***********")

            # -*- Prepare input message for the current_task
            input_for_current_task: str = ""
            if message is not None:
                input_for_current_task += "Respond to the following message from a user:\n"
                input_for_current_task += f"{message}"

            if len(previous_tasks) > 0:
                previous_task_outputs = []
                for previous_task_idx, previous_task in enumerate(previous_tasks, start=1):
                    previous_task_output = previous_task.get_task_output()
                    if previous_task_output is not None:
                        previous_task_outputs.append((previous_task_idx, previous_task.description, previous_task_output))

                if len(previous_task_outputs) > 0:
                    logger.debug(f"Previous tasks: {previous_task_outputs}")
                    input_for_current_task += "\nHere are previous tasks and and their results:\n"
                    for previous_task_idx, previous_task_description, previous_task_output in previous_task_outputs:
                        input_for_current_task += f"\nTask {previous_task_idx}: {previous_task_description}\n"
                        input_for_current_task += previous_task_output
                        input_for_current_task += "\n"

            # -*- Run Task
            if stream:
                yield from task.run(message=input_for_current_task, stream=True, **kwargs)

            previous_tasks.append(task)
            logger.debug(f"*********** Task {idx} End ***********")
        #
        # # -*- Generate response by running tasks
        # for idx, task in enumerate(tasks, start=1):
        #     logger.debug(f"*********** Task {idx} Start ***********")
        #
        #     # Get the Assistant for the current task
        #     task_assistant = self.get_task_assistant(task=task, message=message)
        #
        #     # -*- Prepare input message for the current_task
        #     input_for_current_task: str = ""
        #     if message is not None:
        #         input_for_current_task = f"User Message: {message}\n\n"
        #
        #     if len(previous_tasks) > 0:
        #         previous_task_outputs = []
        #         for previous_task_idx, previous_task in enumerate(previous_tasks, start=1):
        #             previous_task_output = previous_task.get_task_output()
        #             if previous_task_output is not None:
        #                 previous_task_outputs.append((previous_task_idx, previous_task.description, previous_task_output))
        #
        #         if len(previous_task_outputs) > 0:
        #             logger.debug(f"Previous tasks: {previous_task_outputs}")
        #             input_for_current_task += "\n\nHere are previous tasks and and their results:\n"
        #             for previous_task_idx, previous_task_description, previous_task_output in previous_task_outputs:
        #                 input_for_current_task += f"\n\nTask {previous_task_idx}: {previous_task_description}\n"
        #                 input_for_current_task += previous_task_output
        #
        #     # -*- Run Task
        #     task_output = ""
        #     if stream and task_assistant.streamable:
        #         for chunk in task_assistant.run(message=input_for_current_task, stream=True, **kwargs):
        #             task_output += chunk if isinstance(chunk, str) else ""
        #             if task.show_output:
        #                 yield chunk if isinstance(chunk, str) else ""
        #
        #     task.output = task_output
        #     previous_tasks.append(task)
        #     logger.debug(f"*********** Task {idx} End ***********")

        #
        # # Final LLM response after running all tasks
        # run_output = ""
        # # Variable to hold the current task
        # current_task: Optional[Task] = None
        #
        # # -*- Generate response by running tasks
        # for idx, task in enumerate(_tasks, start=1):
        #     logger.debug(f"*********** Task {idx} Start ***********")
        #
        #     # Get the team leader
        #     leader = self.get_task_assistant(task)
        #
        #     run_input += "\n\nHere are previous tasks and and their results:\n"
        #     run_input += f"\n\nTask {idx}: {task.description}\n"
        #
        #     # Set previous_task and current_task
        #     previous_task = current_task
        #     if previous_task is not None and previous_task.show_output:
        #         if stream:
        #             yield "\n\n"
        #         run_output += "\n\n"
        #
        #     current_task = task
        #
        #     # -*- Prepare input message for the current_task
        #     # message_for_current_task: Optional[Union[List, Dict, str]] = None
        #     # if previous_task is not None:
        #     #     previous_task_output = previous_task.get_output_for_next_run()
        #     #     if previous_task_output is not None:
        #     #         message_for_current_task = previous_task_output
        #     # else:
        #     #     message_for_current_task = message
        #
        #     # -*- Update Task
        #     # Add run state to the task
        #     current_task.run_id = self.run_id
        #     current_task.team_name = self.name
        #     current_task.team_memory = self.memory
        #     current_task.run_message = message
        #     current_task.run_task_data = task_data
        #
        #     # -*- Run Task
        #     # current_task_input = current_task.get_input_for_run(message_for_current_task)
        #     if stream and leader.streamable:
        #         for chunk in leader.run(message=run_input, stream=True, **kwargs):
        #             if current_task.show_output:
        #                 run_output += chunk if isinstance(chunk, str) else ""
        #                 run_input += chunk if isinstance(chunk, str) else ""
        #                 yield chunk if isinstance(chunk, str) else ""
        #     else:
        #         current_task_response = leader.run(message=run_input, stream=False, **kwargs)  # type: ignore
        #         current_task_response_str = ""
        #         try:
        #             if current_task_response:
        #                 if isinstance(current_task_response, str):
        #                     current_task_response_str = current_task_response
        #                 elif issubclass(current_task_response.__class__, BaseModel):
        #                     current_task_response_str = current_task_response.model_dump_json(
        #                         exclude_none=True, indent=2
        #                     )
        #                 else:
        #                     current_task_response_str = json.dumps(current_task_response)
        #
        #                 if current_task.show_output:
        #                     if stream:
        #                         yield current_task_response_str
        #                     else:
        #                         run_output += current_task_response_str
        #         except Exception as e:
        #             logger.debug(f"Failed to convert task response to json: {e}")
        #     run_input += "\n\n---\n\n"
        #
        #     logger.debug(f"*********** Task {idx} End ***********")
        #
        # # -*- Save run to storage
        # # self.write_to_storage()
        #
        # # -*- Send run event for monitoring
        # # Response type for this run
        # llm_response_type = "text"
        # if self.markdown:
        #     llm_response_type = "markdown"
        # event_info: Dict[str, Any] = {
        #     "tasks": task_data,
        # }
        # event_data = {
        #     "run_type": "team",
        #     "user_message": message,
        #     "team_response": run_output,
        #     "team_response_type": llm_response_type,
        #     "info": event_info,
        #     "metrics": self.llm.metrics if self.llm else None,
        # }
        # # self._api_log_assistant_event(event_type="run", event_data=event_data)
        #
        # # -*- Update run output
        # self.output = run_output
        # logger.debug(f"*********** Team Run End: {self.run_id} ***********")
        #
        # # -*- Yield final response if not streaming
        # if not stream:
        #     yield run_output

    def run(
        self,
        message: Optional[Union[List, Dict, str]] = None,
        *,
        stream: bool = True,
        **kwargs: Any,
    ) -> Union[Iterator[str], str]:
        if stream and self.streamable:
            resp = self._run(message=message, stream=True, **kwargs)
            return resp
        else:
            resp = self._run(message=message, stream=True, **kwargs)
            return next(resp)

    def print_response(
        self,
        message: Optional[Union[List, Dict, str]] = None,
        *,
        messages: Optional[List[Union[Dict, Message]]] = None,
        stream: bool = True,
        markdown: bool = False,
        show_message: bool = True,
        **kwargs: Any,
    ) -> None:
        from phi.cli.console import console
        from rich.live import Live
        from rich.table import Table
        from rich.status import Status
        from rich.progress import Progress, SpinnerColumn, TextColumn
        from rich.box import ROUNDED
        from rich.markdown import Markdown

        if markdown:
            self.markdown = True

        if stream:
            response = ""
            with Live() as live_log:
                status = Status("Working...", spinner="dots")
                live_log.update(status)
                response_timer = Timer()
                response_timer.start()
                for resp in self.run(message=message, messages=messages, stream=True, **kwargs):
                    if isinstance(resp, str):
                        response += resp
                    _response = Markdown(response) if self.markdown else response

                    table = Table(box=ROUNDED, border_style="blue", show_header=False)
                    if message and show_message:
                        table.show_header = True
                        table.add_column("Message")
                        table.add_column(get_text_from_message(message))
                    table.add_row(f"Response\n({response_timer.elapsed:.1f}s)", _response)  # type: ignore
                    live_log.update(table)
                response_timer.stop()
        else:
            response_timer = Timer()
            response_timer.start()
            with Progress(
                SpinnerColumn(spinner_name="dots"), TextColumn("{task.description}"), transient=True
            ) as progress:
                progress.add_task("Working...")
                response = self.run(message=message, messages=messages, stream=False, **kwargs)  # type: ignore

            response_timer.stop()
            _response = Markdown(response) if self.markdown else self.convert_response_to_string(response)

            table = Table(box=ROUNDED, border_style="blue", show_header=False)
            if message and show_message:
                table.show_header = True
                table.add_column("Message")
                table.add_column(get_text_from_message(message))
            table.add_row(f"Response\n({response_timer.elapsed:.1f}s)", _response)  # type: ignore
            console.print(table)

    def cli_app(
        self,
        user: str = "User",
        emoji: str = ":sunglasses:",
        stream: bool = True,
        markdown: bool = False,
        exit_on: Optional[List[str]] = None,
    ) -> None:
        from rich.prompt import Prompt

        _exit_on = exit_on or ["exit", "quit", "bye"]
        while True:
            message = Prompt.ask(f"[bold] {emoji} {user} [/bold]")
            if message in _exit_on:
                break

            self.print_response(message=message, stream=stream, markdown=markdown)
