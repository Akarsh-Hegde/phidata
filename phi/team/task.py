import json
from uuid import uuid4
from typing import List, Any, Optional, Dict, Union, Type

from pydantic import BaseModel, ConfigDict, field_validator, Field

from phi.assistant import Assistant
from phi.memory.team import TeamMemory


class Task(BaseModel):
    # -*- Task settings
    # Task UUID (autogenerated if not set)
    task_id: str = Field(None, validate_default=True)
    # Task description
    description: Optional[str] = None
    # Instructions for the task
    instructions: Optional[List[str]] = None

    # -*- Team information
    team_name: Optional[str] = None
    team_memory: Optional[TeamMemory] = None

    # Assistants assigned to this task
    assistants: Optional[List[Assistant]] = None

    # -*- Run state
    run_id: Optional[str] = None
    run_message: Optional[Union[List, Dict, str]] = None
    run_task_data: Optional[List[Dict[str, Any]]] = None

    # -*- Task Output Settings
    # Provide an output model for the responses
    output_model: Optional[Union[str, List, Type[BaseModel]]] = None
    # If True, the output is converted into the output_model (pydantic model or json dict)
    parse_output: bool = True
    # -*- Final output of this Task
    output: Optional[Any] = None
    # If True, shows the output of the task in the assistant.run()
    show_output: bool = True

    model_config = ConfigDict(arbitrary_types_allowed=True)

    @field_validator("task_id", mode="before")
    def set_task_id(cls, v: Optional[str]) -> str:
        return v if v is not None else str(uuid4())

    def get_input_for_run(self, message: Optional[str] = None) -> str:
        return message

    def get_output_for_next_run(self) -> Optional[str]:
        if self.output is None:
            return None

        if isinstance(self.output, str):
            return self.output

        if issubclass(self.output.__class__, BaseModel):
            # Convert current_task_message to json if it is a BaseModel
            return self.output.model_dump_json(exclude_none=True, indent=2)

        return json.dumps(self.output, indent=2)
