from os import getenv
from uuid import uuid4
from typing import Any, Optional, Callable, Dict

from pydantic import BaseModel, Field, ConfigDict, field_validator, PrivateAttr

from phi.run.response import RunResponse
from phi.workflow.session import WorkflowSession
from phi.utils.log import logger, set_log_level_to_debug, set_log_level_to_info
from phi.utils.merge_dict import merge_dictionaries


class Workflow(BaseModel):
    # -*- Workflow settings
    # Workflow name
    name: Optional[str] = None
    # Workflow UUID (autogenerated if not set)
    workflow_id: Optional[str] = Field(None, validate_default=True)
    # Metadata associated with this workflow
    workflow_data: Optional[Dict[str, Any]] = None

    # -*- User settings
    # ID of the user interacting with this workflow
    user_id: Optional[str] = None
    # Metadata associated with the user interacting with this workflow
    user_data: Optional[Dict[str, Any]] = None

    # -*- Session settings
    # Session UUID (autogenerated if not set)
    session_id: Optional[str] = Field(None, validate_default=True)
    # Session name
    session_name: Optional[str] = None
    # Metadata associated with this session
    session_data: Optional[Dict[str, Any]] = None
    # Session state stored in the database
    session_state: Optional[Dict[str, Any]] = None

    # -*- Workflow Storage
    storage: Optional[Any] = None
    # WorkflowSession from the database: DO NOT SET MANUALLY
    _workflow_session: Optional[WorkflowSession] = None

    # debug_mode=True enables debug logs
    debug_mode: bool = Field(False, validate_default=True)
    # monitoring=True logs workflow information to phidata.com
    monitoring: bool = getenv("PHI_MONITORING", "false").lower() == "true"
    # telemetry=True logs minimal telemetry for analytics
    # This helps us improve the Agent and provide better support
    telemetry: bool = getenv("PHI_TELEMETRY", "true").lower() == "true"

    # DO NOT SET THE FOLLOWING FIELDS MANUALLY
    # -*- Workflow run details
    # Run ID: do not set manually
    run_id: Optional[str] = None
    # Response from the Workflow run: do not set manually
    run_response: RunResponse = Field(default_factory=RunResponse)

    # The run function provided by the subclass
    _subclass_run: Callable = PrivateAttr()

    model_config = ConfigDict(arbitrary_types_allowed=True, populate_by_name=True)

    @field_validator("workflow_id", mode="before")
    def set_workflow_id(cls, v: Optional[str]) -> str:
        workflow_id = v or str(uuid4())
        logger.debug(f"*********** Worfklow ID: {workflow_id} ***********")
        return workflow_id

    @field_validator("session_id", mode="before")
    def set_session_id(cls, v: Optional[str]) -> str:
        session_id = v or str(uuid4())
        logger.debug(f"*********** Worflow Session ID: {session_id} ***********")
        return session_id

    @field_validator("debug_mode", mode="before")
    def set_log_level(cls, v: bool) -> bool:
        if v or getenv("PHI_DEBUG", "false").lower() == "true":
            set_log_level_to_debug()
            logger.debug("Debug logs enabled")
        elif v is False:
            set_log_level_to_info()
        return v

    def get_workflow_data(self) -> Dict[str, Any]:
        workflow_data = self.workflow_data or {}
        if self.name is not None:
            workflow_data["name"] = self.name
        return workflow_data

    def get_session_data(self) -> Dict[str, Any]:
        session_data = self.session_data or {}
        if self.session_name is not None:
            session_data["session_name"] = self.session_name
        return session_data

    def get_workflow_session(self) -> WorkflowSession:
        """Get a WorkflowSession object, which can be saved to the database"""

        return WorkflowSession(
            session_id=self.session_id,
            workflow_id=self.workflow_id,
            user_id=self.user_id,
            workflow_data=self.get_workflow_data(),
            user_data=self.user_data,
            session_data=self.get_session_data(),
            session_state=self.session_state,
        )

    def from_workflow_session(self, session: WorkflowSession):
        """Load the existing Workflow from a WorkflowSession (from the database)"""

        # Get the session_id, workflow_id and user_id from the WorkflowSession
        if self.session_id is None and session.session_id is not None:
            self.session_id = session.session_id
        if self.workflow_id is None and session.workflow_id is not None:
            self.workflow_id = session.workflow_id
        if self.user_id is None and session.user_id is not None:
            self.user_id = session.user_id

        # Get the name from WorkflowSession and update the current name if not set
        if self.name is None and session.workflow_data is not None and "name" in session.workflow_data:
            self.name = session.workflow_data.get("name")

        # Get the session_data from WorkflowSession and update the current Workflow if not set
        if self.session_name is None and session.session_data is not None and "session_name" in session.session_data:
            self.session_name = session.session_data.get("session_name")

        # Read workflow_data from the database
        if session.workflow_data is not None:
            # If workflow_data is set in the workflow, merge it with the database workflow_data.
            # The workflow's workflow_data takes precedence
            if self.workflow_data is not None:
                # Updates workflow_session.workflow_data with self.workflow_data
                merge_dictionaries(session.workflow_data, self.workflow_data)
                self.workflow_data = session.workflow_data
            # If workflow_data is not set in the workflow, use the database workflow_data
            if self.workflow_data is None:
                self.workflow_data = session.workflow_data

        # Read session_data from the database
        if session.session_data is not None:
            # If session_data is set in the workflow, merge it with the database session_data.
            # The workflow's session_data takes precedence
            if self.session_data is not None:
                # Updates workflow_session.session_data with self.session_data
                merge_dictionaries(session.session_data, self.session_data)
                self.session_data = session.session_data
            # If session_data is not set in the workflow, use the database session_data
            if self.session_data is None:
                self.session_data = session.session_data

        # Read user_data from the database
        if session.user_data is not None:
            # If user_data is set in the workflow, merge it with the database user_data.
            # The workflow's user_data takes precedence
            if self.user_data is not None:
                # Updates workflow_session.user_data with self.user_data
                merge_dictionaries(session.user_data, self.user_data)
                self.user_data = session.user_data
            # If user_data is not set in the workflow, use the database user_data
            if self.user_data is None:
                self.user_data = session.user_data

        # Read session_state from the database
        if session.session_state is not None:
            # If session_state is set in the workflow, merge it with the database session_state.
            # The workflow's session_state takes precedence
            if self.session_state is not None:
                # Updates workflow_session.session_state with self.session_state
                merge_dictionaries(session.session_state, self.session_state)
                self.session_state = session.session_state
            # If session_state is not set in the workflow, use the database session_state
            if self.session_state is None:
                self.session_state = session.session_state
        logger.debug(f"-*- WorkflowSession loaded: {session.session_id}")

    def read_from_storage(self) -> Optional[WorkflowSession]:
        """Load the WorkflowSession from storage"""

        if self.storage is not None and self.session_id is not None:
            self._workflow_session = self.storage.read(session_id=self.session_id)
            if self._workflow_session is not None:
                self.from_workflow_session(session=self._workflow_session)
        return self._workflow_session

    def write_to_storage(self) -> Optional[WorkflowSession]:
        """Save the WorkflowSession to storage"""

        if self.storage is not None:
            self._workflow_session = self.storage.upsert(session=self.get_workflow_session())
        return self._workflow_session

    def run(self, *args: Any, **kwargs: Any):
        logger.error(f"{self.__class__.__name__}.run() method not implemented.")
        return

    def run_workflow(self, *args: Any, **kwargs: Any):
        self.run_id = str(uuid4())

        logger.debug(f"*********** Running Workflow: {self.run_id} ***********")
        result = self._subclass_run(*args, **kwargs)
        return result

    def __init__(self, **data):
        super().__init__(**data)
        # Check if 'run' is provided by the subclass
        if self.__class__.run is not Workflow.run:
            # Store the original run method bound to the instance
            self._subclass_run = self.__class__.run.__get__(self)
            # Replace the instance's run method with run_workflow
            object.__setattr__(self, "run", self.run_workflow.__get__(self))
        else:
            # This will log an error when called
            self._subclass_run = self.run
